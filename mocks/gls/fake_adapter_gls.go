// Code generated by MockGen. DO NOT EDIT.
// Source: git.multiverse.io/eventkit/kit/gls (interfaces: ShardingDataOperator)

// Package gls is a generated GoMock package.
package gls

import (
	context "context"
	reflect "reflect"

	gls "git.multiverse.io/eventkit/kit/gls"
	errors "git.multiverse.io/eventkit/kit/common/errors"
	gomock "github.com/golang/mock/gomock"
)

// MockShardingDataOperator is a mock of ShardingDataOperator interface.
type MockShardingDataOperator struct {
	ctrl     *gomock.Controller
	recorder *MockShardingDataOperatorMockRecorder
}

// MockShardingDataOperatorMockRecorder is the mock recorder for MockShardingDataOperator.
type MockShardingDataOperatorMockRecorder struct {
	mock *MockShardingDataOperator
}

// NewMockShardingDataOperator creates a new mock instance.
func NewMockShardingDataOperator(ctrl *gomock.Controller) *MockShardingDataOperator {
	mock := &MockShardingDataOperator{ctrl: ctrl}
	mock.recorder = &MockShardingDataOperatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockShardingDataOperator) EXPECT() *MockShardingDataOperatorMockRecorder {
	return m.recorder
}

// AppendIntoBoundRelationWithSUType mocks base method.
func (m *MockShardingDataOperator) AppendIntoBoundRelationWithSUType(arg0 context.Context, arg1 string, arg2, arg3 *gls.ShardingData, arg4 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AppendIntoBoundRelationWithSUType", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// AppendIntoBoundRelationWithSUType indicates an expected call of AppendIntoBoundRelationWithSUType.
func (mr *MockShardingDataOperatorMockRecorder) AppendIntoBoundRelationWithSUType(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendIntoBoundRelationWithSUType", reflect.TypeOf((*MockShardingDataOperator)(nil).AppendIntoBoundRelationWithSUType), varargs...)
}

// AppendIntoBoundRelationWithTopicInfo mocks base method.
func (m *MockShardingDataOperator) AppendIntoBoundRelationWithTopicInfo(arg0 context.Context, arg1 *gls.TopicInfo, arg2, arg3 *gls.ShardingData, arg4 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AppendIntoBoundRelationWithTopicInfo", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// AppendIntoBoundRelationWithTopicInfo indicates an expected call of AppendIntoBoundRelationWithTopicInfo.
func (mr *MockShardingDataOperatorMockRecorder) AppendIntoBoundRelationWithTopicInfo(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendIntoBoundRelationWithTopicInfo", reflect.TypeOf((*MockShardingDataOperator)(nil).AppendIntoBoundRelationWithTopicInfo), varargs...)
}

// AppendIntoSUWithSUType mocks base method.
func (m *MockShardingDataOperator) AppendIntoSUWithSUType(arg0 context.Context, arg1, arg2 string, arg3 *gls.ShardingData, arg4 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AppendIntoSUWithSUType", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// AppendIntoSUWithSUType indicates an expected call of AppendIntoSUWithSUType.
func (mr *MockShardingDataOperatorMockRecorder) AppendIntoSUWithSUType(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendIntoSUWithSUType", reflect.TypeOf((*MockShardingDataOperator)(nil).AppendIntoSUWithSUType), varargs...)
}

// AppendIntoSUWithTopicInfo mocks base method.
func (m *MockShardingDataOperator) AppendIntoSUWithTopicInfo(arg0 context.Context, arg1 *gls.TopicInfo, arg2 string, arg3 *gls.ShardingData, arg4 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AppendIntoSUWithTopicInfo", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// AppendIntoSUWithTopicInfo indicates an expected call of AppendIntoSUWithTopicInfo.
func (mr *MockShardingDataOperatorMockRecorder) AppendIntoSUWithTopicInfo(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendIntoSUWithTopicInfo", reflect.TypeOf((*MockShardingDataOperator)(nil).AppendIntoSUWithTopicInfo), varargs...)
}

// AppendListIntoBoundRelationWithSUType mocks base method.
func (m *MockShardingDataOperator) AppendListIntoBoundRelationWithSUType(arg0 context.Context, arg1 string, arg2 *gls.ShardingData, arg3 []*gls.ShardingData, arg4 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AppendListIntoBoundRelationWithSUType", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// AppendListIntoBoundRelationWithSUType indicates an expected call of AppendListIntoBoundRelationWithSUType.
func (mr *MockShardingDataOperatorMockRecorder) AppendListIntoBoundRelationWithSUType(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendListIntoBoundRelationWithSUType", reflect.TypeOf((*MockShardingDataOperator)(nil).AppendListIntoBoundRelationWithSUType), varargs...)
}

// AppendListIntoBoundRelationWithTopicInfo mocks base method.
func (m *MockShardingDataOperator) AppendListIntoBoundRelationWithTopicInfo(arg0 context.Context, arg1 *gls.TopicInfo, arg2 *gls.ShardingData, arg3 []*gls.ShardingData, arg4 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AppendListIntoBoundRelationWithTopicInfo", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// AppendListIntoBoundRelationWithTopicInfo indicates an expected call of AppendListIntoBoundRelationWithTopicInfo.
func (mr *MockShardingDataOperatorMockRecorder) AppendListIntoBoundRelationWithTopicInfo(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendListIntoBoundRelationWithTopicInfo", reflect.TypeOf((*MockShardingDataOperator)(nil).AppendListIntoBoundRelationWithTopicInfo), varargs...)
}

// AppendListIntoSUWithSUType mocks base method.
func (m *MockShardingDataOperator) AppendListIntoSUWithSUType(arg0 context.Context, arg1, arg2 string, arg3 []*gls.ShardingData, arg4 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AppendListIntoSUWithSUType", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// AppendListIntoSUWithSUType indicates an expected call of AppendListIntoSUWithSUType.
func (mr *MockShardingDataOperatorMockRecorder) AppendListIntoSUWithSUType(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendListIntoSUWithSUType", reflect.TypeOf((*MockShardingDataOperator)(nil).AppendListIntoSUWithSUType), varargs...)
}

// AppendListIntoSUWithTopicInfo mocks base method.
func (m *MockShardingDataOperator) AppendListIntoSUWithTopicInfo(arg0 context.Context, arg1 *gls.TopicInfo, arg2 string, arg3 []*gls.ShardingData, arg4 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AppendListIntoSUWithTopicInfo", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// AppendListIntoSUWithTopicInfo indicates an expected call of AppendListIntoSUWithTopicInfo.
func (mr *MockShardingDataOperatorMockRecorder) AppendListIntoSUWithTopicInfo(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendListIntoSUWithTopicInfo", reflect.TypeOf((*MockShardingDataOperator)(nil).AppendListIntoSUWithTopicInfo), varargs...)
}

// BindListWithSUType mocks base method.
func (m *MockShardingDataOperator) BindListWithSUType(arg0 context.Context, arg1 string, arg2 []*gls.ShardingData, arg3 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BindListWithSUType", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// BindListWithSUType indicates an expected call of BindListWithSUType.
func (mr *MockShardingDataOperatorMockRecorder) BindListWithSUType(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BindListWithSUType", reflect.TypeOf((*MockShardingDataOperator)(nil).BindListWithSUType), varargs...)
}

// BindListWithTopicInfo mocks base method.
func (m *MockShardingDataOperator) BindListWithTopicInfo(arg0 context.Context, arg1 *gls.TopicInfo, arg2 []*gls.ShardingData, arg3 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BindListWithTopicInfo", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// BindListWithTopicInfo indicates an expected call of BindListWithTopicInfo.
func (mr *MockShardingDataOperatorMockRecorder) BindListWithTopicInfo(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BindListWithTopicInfo", reflect.TypeOf((*MockShardingDataOperator)(nil).BindListWithTopicInfo), varargs...)
}

// BindWithSUType mocks base method.
func (m *MockShardingDataOperator) BindWithSUType(arg0 context.Context, arg1 string, arg2 *gls.ShardingData, arg3 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BindWithSUType", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// BindWithSUType indicates an expected call of BindWithSUType.
func (mr *MockShardingDataOperatorMockRecorder) BindWithSUType(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BindWithSUType", reflect.TypeOf((*MockShardingDataOperator)(nil).BindWithSUType), varargs...)
}

// BindWithTopicInfo mocks base method.
func (m *MockShardingDataOperator) BindWithTopicInfo(arg0 context.Context, arg1 *gls.TopicInfo, arg2 *gls.ShardingData, arg3 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BindWithTopicInfo", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// BindWithTopicInfo indicates an expected call of BindWithTopicInfo.
func (mr *MockShardingDataOperatorMockRecorder) BindWithTopicInfo(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BindWithTopicInfo", reflect.TypeOf((*MockShardingDataOperator)(nil).BindWithTopicInfo), varargs...)
}

// IsBoundWithSUType mocks base method.
func (m *MockShardingDataOperator) IsBoundWithSUType(arg0 context.Context, arg1 string, arg2 *gls.ShardingData, arg3 ...gls.Option) (bool, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "IsBoundWithSUType", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// IsBoundWithSUType indicates an expected call of IsBoundWithSUType.
func (mr *MockShardingDataOperatorMockRecorder) IsBoundWithSUType(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsBoundWithSUType", reflect.TypeOf((*MockShardingDataOperator)(nil).IsBoundWithSUType), varargs...)
}

// IsBoundWithTopicInfo mocks base method.
func (m *MockShardingDataOperator) IsBoundWithTopicInfo(arg0 context.Context, arg1 *gls.TopicInfo, arg2 *gls.ShardingData, arg3 ...gls.Option) (bool, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "IsBoundWithTopicInfo", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// IsBoundWithTopicInfo indicates an expected call of IsBoundWithTopicInfo.
func (mr *MockShardingDataOperatorMockRecorder) IsBoundWithTopicInfo(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsBoundWithTopicInfo", reflect.TypeOf((*MockShardingDataOperator)(nil).IsBoundWithTopicInfo), varargs...)
}

// LookupListUsingSUType mocks base method.
func (m *MockShardingDataOperator) LookupListUsingSUType(arg0 context.Context, arg1 string, arg2 []*gls.ShardingData, arg3 ...gls.Option) ([]*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LookupListUsingSUType", varargs...)
	ret0, _ := ret[0].([]*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// LookupListUsingSUType indicates an expected call of LookupListUsingSUType.
func (mr *MockShardingDataOperatorMockRecorder) LookupListUsingSUType(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LookupListUsingSUType", reflect.TypeOf((*MockShardingDataOperator)(nil).LookupListUsingSUType), varargs...)
}

// LookupListUsingTopicInfo mocks base method.
func (m *MockShardingDataOperator) LookupListUsingTopicInfo(arg0 context.Context, arg1 *gls.TopicInfo, arg2 []*gls.ShardingData, arg3 ...gls.Option) ([]*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LookupListUsingTopicInfo", varargs...)
	ret0, _ := ret[0].([]*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// LookupListUsingTopicInfo indicates an expected call of LookupListUsingTopicInfo.
func (mr *MockShardingDataOperatorMockRecorder) LookupListUsingTopicInfo(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LookupListUsingTopicInfo", reflect.TypeOf((*MockShardingDataOperator)(nil).LookupListUsingTopicInfo), varargs...)
}

// LookupUsingSUType mocks base method.
func (m *MockShardingDataOperator) LookupUsingSUType(arg0 context.Context, arg1 string, arg2 *gls.ShardingData, arg3 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LookupUsingSUType", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// LookupUsingSUType indicates an expected call of LookupUsingSUType.
func (mr *MockShardingDataOperatorMockRecorder) LookupUsingSUType(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LookupUsingSUType", reflect.TypeOf((*MockShardingDataOperator)(nil).LookupUsingSUType), varargs...)
}

// LookupUsingTopicInfo mocks base method.
func (m *MockShardingDataOperator) LookupUsingTopicInfo(arg0 context.Context, arg1 *gls.TopicInfo, arg2 *gls.ShardingData, arg3 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LookupUsingTopicInfo", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// LookupUsingTopicInfo indicates an expected call of LookupUsingTopicInfo.
func (mr *MockShardingDataOperatorMockRecorder) LookupUsingTopicInfo(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LookupUsingTopicInfo", reflect.TypeOf((*MockShardingDataOperator)(nil).LookupUsingTopicInfo), varargs...)
}

// QuerySuListUsingSUType mocks base method.
func (m *MockShardingDataOperator) QuerySuListUsingSUType(arg0 context.Context, arg1 string, arg2 ...gls.Option) (*gls.SuTypeInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QuerySuListUsingSUType", varargs...)
	ret0, _ := ret[0].(*gls.SuTypeInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// QuerySuListUsingSUType indicates an expected call of QuerySuListUsingSUType.
func (mr *MockShardingDataOperatorMockRecorder) QuerySuListUsingSUType(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QuerySuListUsingSUType", reflect.TypeOf((*MockShardingDataOperator)(nil).QuerySuListUsingSUType), varargs...)
}

// QuerySuListUsingSUTypeList mocks base method.
func (m *MockShardingDataOperator) QuerySuListUsingSUTypeList(arg0 context.Context, arg1 []string, arg2 ...gls.Option) ([]*gls.SuTypeInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QuerySuListUsingSUTypeList", varargs...)
	ret0, _ := ret[0].([]*gls.SuTypeInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// QuerySuListUsingSUTypeList indicates an expected call of QuerySuListUsingSUTypeList.
func (mr *MockShardingDataOperatorMockRecorder) QuerySuListUsingSUTypeList(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QuerySuListUsingSUTypeList", reflect.TypeOf((*MockShardingDataOperator)(nil).QuerySuListUsingSUTypeList), varargs...)
}

// QuerySuListUsingTopicInfo mocks base method.
func (m *MockShardingDataOperator) QuerySuListUsingTopicInfo(arg0 context.Context, arg1 *gls.TopicInfo, arg2 ...gls.Option) (*gls.SuTypeInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QuerySuListUsingTopicInfo", varargs...)
	ret0, _ := ret[0].(*gls.SuTypeInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// QuerySuListUsingTopicInfo indicates an expected call of QuerySuListUsingTopicInfo.
func (mr *MockShardingDataOperatorMockRecorder) QuerySuListUsingTopicInfo(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QuerySuListUsingTopicInfo", reflect.TypeOf((*MockShardingDataOperator)(nil).QuerySuListUsingTopicInfo), varargs...)
}

// QuerySuListUsingTopicInfoList mocks base method.
func (m *MockShardingDataOperator) QuerySuListUsingTopicInfoList(arg0 context.Context, arg1 []gls.TopicInfo, arg2 ...gls.Option) ([]*gls.SuTypeInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QuerySuListUsingTopicInfoList", varargs...)
	ret0, _ := ret[0].([]*gls.SuTypeInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// QuerySuListUsingTopicInfoList indicates an expected call of QuerySuListUsingTopicInfoList.
func (mr *MockShardingDataOperatorMockRecorder) QuerySuListUsingTopicInfoList(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QuerySuListUsingTopicInfoList", reflect.TypeOf((*MockShardingDataOperator)(nil).QuerySuListUsingTopicInfoList), varargs...)
}

// ReBindListWithSUType mocks base method.
func (m *MockShardingDataOperator) ReBindListWithSUType(arg0 context.Context, arg1 string, arg2 []*gls.ReBindShardingData, arg3 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReBindListWithSUType", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// ReBindListWithSUType indicates an expected call of ReBindListWithSUType.
func (mr *MockShardingDataOperatorMockRecorder) ReBindListWithSUType(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReBindListWithSUType", reflect.TypeOf((*MockShardingDataOperator)(nil).ReBindListWithSUType), varargs...)
}

// ReBindListWithTopicInfo mocks base method.
func (m *MockShardingDataOperator) ReBindListWithTopicInfo(arg0 context.Context, arg1 *gls.TopicInfo, arg2 []*gls.ReBindShardingData, arg3 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReBindListWithTopicInfo", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// ReBindListWithTopicInfo indicates an expected call of ReBindListWithTopicInfo.
func (mr *MockShardingDataOperatorMockRecorder) ReBindListWithTopicInfo(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReBindListWithTopicInfo", reflect.TypeOf((*MockShardingDataOperator)(nil).ReBindListWithTopicInfo), varargs...)
}

// ReBindWithSUType mocks base method.
func (m *MockShardingDataOperator) ReBindWithSUType(arg0 context.Context, arg1 string, arg2 *gls.ReBindShardingData, arg3 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReBindWithSUType", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// ReBindWithSUType indicates an expected call of ReBindWithSUType.
func (mr *MockShardingDataOperatorMockRecorder) ReBindWithSUType(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReBindWithSUType", reflect.TypeOf((*MockShardingDataOperator)(nil).ReBindWithSUType), varargs...)
}

// ReBindWithTopicInfo mocks base method.
func (m *MockShardingDataOperator) ReBindWithTopicInfo(arg0 context.Context, arg1 *gls.TopicInfo, arg2 *gls.ReBindShardingData, arg3 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReBindWithTopicInfo", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// ReBindWithTopicInfo indicates an expected call of ReBindWithTopicInfo.
func (mr *MockShardingDataOperatorMockRecorder) ReBindWithTopicInfo(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReBindWithTopicInfo", reflect.TypeOf((*MockShardingDataOperator)(nil).ReBindWithTopicInfo), varargs...)
}

// RemoveAllBoundRelation mocks base method.
func (m *MockShardingDataOperator) RemoveAllBoundRelation(arg0 context.Context, arg1 *gls.ShardingData, arg2 ...gls.Option) *errors.Error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RemoveAllBoundRelation", varargs...)
	ret0, _ := ret[0].(*errors.Error)
	return ret0
}

// RemoveAllBoundRelation indicates an expected call of RemoveAllBoundRelation.
func (mr *MockShardingDataOperatorMockRecorder) RemoveAllBoundRelation(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveAllBoundRelation", reflect.TypeOf((*MockShardingDataOperator)(nil).RemoveAllBoundRelation), varargs...)
}

// UnBindListWithSUType mocks base method.
func (m *MockShardingDataOperator) UnBindListWithSUType(arg0 context.Context, arg1 string, arg2 []*gls.ShardingData, arg3 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UnBindListWithSUType", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// UnBindListWithSUType indicates an expected call of UnBindListWithSUType.
func (mr *MockShardingDataOperatorMockRecorder) UnBindListWithSUType(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnBindListWithSUType", reflect.TypeOf((*MockShardingDataOperator)(nil).UnBindListWithSUType), varargs...)
}

// UnBindListWithTopicInfo mocks base method.
func (m *MockShardingDataOperator) UnBindListWithTopicInfo(arg0 context.Context, arg1 *gls.TopicInfo, arg2 []*gls.ShardingData, arg3 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UnBindListWithTopicInfo", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// UnBindListWithTopicInfo indicates an expected call of UnBindListWithTopicInfo.
func (mr *MockShardingDataOperatorMockRecorder) UnBindListWithTopicInfo(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnBindListWithTopicInfo", reflect.TypeOf((*MockShardingDataOperator)(nil).UnBindListWithTopicInfo), varargs...)
}

// UnBindWithSUType mocks base method.
func (m *MockShardingDataOperator) UnBindWithSUType(arg0 context.Context, arg1 string, arg2 *gls.ShardingData, arg3 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UnBindWithSUType", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// UnBindWithSUType indicates an expected call of UnBindWithSUType.
func (mr *MockShardingDataOperatorMockRecorder) UnBindWithSUType(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnBindWithSUType", reflect.TypeOf((*MockShardingDataOperator)(nil).UnBindWithSUType), varargs...)
}

// UnBindWithTopicInfo mocks base method.
func (m *MockShardingDataOperator) UnBindWithTopicInfo(arg0 context.Context, arg1 *gls.TopicInfo, arg2 *gls.ShardingData, arg3 ...gls.Option) (*gls.SuInfo, *errors.Error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UnBindWithTopicInfo", varargs...)
	ret0, _ := ret[0].(*gls.SuInfo)
	ret1, _ := ret[1].(*errors.Error)
	return ret0, ret1
}

// UnBindWithTopicInfo indicates an expected call of UnBindWithTopicInfo.
func (mr *MockShardingDataOperatorMockRecorder) UnBindWithTopicInfo(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnBindWithTopicInfo", reflect.TypeOf((*MockShardingDataOperator)(nil).UnBindWithTopicInfo), varargs...)
}
